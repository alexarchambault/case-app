{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"case-app","text":"<p>case-app is command-line argument parser for Scala that relies on case classes</p> <p>It offers to define options in simple case classes, supports sub-commands, offers support for completion, \u2026</p> <p>It supports Scala on the JVM, Scala.js, and Scala Native.</p> <p>It's used by coursier, Scala CLI, Almond, \u2026</p>"},{"location":"advanced/","title":"Advanced topics","text":""},{"location":"advanced/#recovering-argument-positions","title":"Recovering argument positions","text":"<p>One can recover the exact positions of each options and remaining arguments.</p> <p>For options, one should use the <code>Indexed</code> class, like <pre><code>import caseapp.core.Indexed\n\ncase class Options(\n  foo: Indexed[String] = Indexed(\"\")\n)\n\nval (options, _) = CaseApp.parse[Options](Seq(\"a\", \"--foo\", \"thing\")).toOption.get\n// options: Options = Options(\n//   foo = Indexed(index = 1, length = 2, value = \"thing\")\n// )\n</code></pre></p> <p>For arguments that are not options or option values, indices are retained in the <code>RemainingArgs</code> instance: <pre><code>val (_, args) = CaseApp.detailedParse[Options](Seq(\"a\", \"--foo\", \"2\", \"b\")).toOption.get\n</code></pre> <pre><code>args.indexed\n// res1: Seq[Indexed[String]] = List(\n//   Indexed(index = 0, length = 1, value = \"a\"),\n//   Indexed(index = 3, length = 1, value = \"b\")\n// )\n</code></pre></p>"},{"location":"advanced/#partial-parsing","title":"Partial parsing","text":"<p>One can stop parsing arguments at the first argument that is not an option, or that is an unknown option. This can be useful when \"pre-processing\" arguments passed to another application later on: case-app parses as much arguments as possible, then stops, so that the other application can parse the remaining arguments later on.</p> <pre><code>case class Options(\n  foo: String = \"\"\n)\n\nobject Options {\n  implicit lazy val parser: Parser[Options] = {\n    val parser0: Parser[Options] = Parser.derive\n    parser0.stopAtFirstUnrecognized\n  }\n  implicit lazy val help: Help[Options] = Help.derive\n}\n</code></pre> <pre><code>val (options, args) = CaseApp.parse[Options](Seq(\"--foo\", \"a\", \"--other\", \"thing\")).toOption.get\n// options: Options = Options(foo = \"a\")\n// args: Seq[String] = List(\"--other\", \"thing\")\n</code></pre> <p>Alternatively, when extending <code>CaseApp</code>, one can do: <pre><code>object MyApp extends CaseApp[Options] {\n  override def stopAtFirstUnrecognized = true\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre></p>"},{"location":"advanced/#ignore-unrecognized-options","title":"Ignore unrecognized options","text":"<p>One can ignore non-recognized options, like <pre><code>case class Options(\n  foo: String = \"\"\n)\n\nobject Options {\n  implicit lazy val parser: Parser[Options] = {\n    val parser0: Parser[Options] = Parser.derive\n    parser0.ignoreUnrecognized\n  }\n  implicit lazy val help: Help[Options] = Help.derive\n}\n</code></pre></p> <pre><code>val (options, args) = CaseApp.parse[Options](Seq(\"--other\", \"thing\", \"--foo\", \"a\")).toOption.get\n// options: Options = Options(foo = \"a\")\n// args: Seq[String] = List(\"--other\", \"thing\")\n</code></pre> <p>Unrecognized options end up in the \"remaining arguments\", along with non-option or non-option values arguments.</p> <p>Alternatively, when extending <code>CaseApp</code>, one can do: <pre><code>object MyApp extends CaseApp[Options] {\n  override def ignoreUnrecognized = true\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre></p>"},{"location":"advanced/#check-for-duplicate-options-in-tests","title":"Check for duplicate options in tests","text":"<p>When using the <code>@Recurse</code> or <code>@Name</code> annotations, some options might be given the same name. In practice, at runtime, one will shadow the other.</p> <p>To ensure your options don't contain duplicates, you can call <code>ensureNoDuplicates</code> on the <code>Help</code> type class instance of your options, or on the <code>CaseApp</code> instance if you defined one: <pre><code>case class Options(\n  foo: String = \"\",\n  @Name(\"foo\")\n    count: Int = 0\n)\n\nobject MyApp extends CaseApp[Options] {\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre></p> <pre><code>Help[Options].ensureNoDuplicates()\n// java.lang.Exception: Found duplicated arguments: --foo (List(Arg(Name(foo), List(), Some(ValueDescription(string)), None, false, false, None, Some(Options), List()), Arg(Name(count), List(Name(foo)), Some(ValueDescription(int)), None, false, false, None, Some(Options), List())) times).\n//  at caseapp.core.help.Help.ensureNoDuplicates(Help.scala:90)\n//  at repl.MdocSession$MdocApp8$$anonfun$56.apply$mcV$sp(advanced.md:208)\n//  at repl.MdocSession$MdocApp8$$anonfun$56.apply(advanced.md:208)\n//  at repl.MdocSession$MdocApp8$$anonfun$56.apply(advanced.md:208)\n</code></pre> <pre><code>MyApp.ensureNoDuplicates()\n// java.lang.Exception: Found duplicated arguments: --foo (List(Arg(Name(foo), List(), Some(ValueDescription(string)), None, false, false, None, Some(Options), List()), Arg(Name(count), List(Name(foo)), Some(ValueDescription(int)), None, false, false, None, Some(Options), List())) times).\n//  at caseapp.core.help.Help.ensureNoDuplicates(Help.scala:90)\n//  at caseapp.core.app.CaseApp.ensureNoDuplicates(CaseApp.scala:108)\n//  at repl.MdocSession$MdocApp8$$anonfun$57.apply$mcV$sp(advanced.md:218)\n//  at repl.MdocSession$MdocApp8$$anonfun$57.apply(advanced.md:218)\n//  at repl.MdocSession$MdocApp8$$anonfun$57.apply(advanced.md:218)\n</code></pre>"},{"location":"commands/","title":"Commands","text":"<p>The use of commands relies on the same API as <code>CaseApp</code>. While it is possible to use the command argument parser in a standalone fashion, sections below assume you're parsing options by extending <code>CaseApp</code> (or its <code>Command</code> sub-class).</p>"},{"location":"commands/#defining-commands","title":"Defining commands","text":"<p>Individual commands are defined as instances of <code>Command</code>, which is itself a sub-class of <code>CaseApp</code>. <code>Command</code> adds a few methods to <code>CaseApp</code>, that can be overridden, most notably <code>name</code> and <code>names</code>.</p> <pre><code>case class FirstOptions(\n  foo: String = \"\"\n)\n\nobject First extends Command[FirstOptions] {\n  override def names = List(\n    List(\"first\"),\n    List(\"frst\"),\n    List(\"command-one\"),\n    List(\"command\", \"one\")\n  )\n  def run(options: FirstOptions, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n\ncase class SecondOptions(\n  foo: String = \"\"\n)\n\nobject Second extends Command[SecondOptions] {\n  override def name = \"command-two\"\n  def run(options: SecondOptions, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre> <p>Individual commands are gathered in an object extending <code>CommandsEntryPoint</code>: <pre><code>object MyApp extends CommandsEntryPoint {\n  def progName = \"my-app\"\n  def commands = Seq(\n    First,\n    Second\n  )\n}\n</code></pre></p>"},{"location":"commands/#customizing-commands-help","title":"Customizing commands help","text":""},{"location":"commands/#enabling-support-for-completion","title":"Enabling support for completion","text":"<p>See completion support</p>"},{"location":"commands/#advanced","title":"Advanced","text":""},{"location":"commands/#hidden-commands","title":"Hidden commands","text":"<p>Overriding the <code>def hidden: Boolean</code> method of <code>Command</code> allows to hide a command from the help message: <pre><code>case class FirstOptions()\n\nobject First extends Command[FirstOptions] {\n  def run(options: FirstOptions, args: RemainingArgs) = {\n    ???\n  }\n}\n\ncase class SecondOptions()\n\nobject Second extends Command[SecondOptions] {\n\n  // hide this command from the command listing in the help message\n  override def hidden = true\n\n  def run(options: SecondOptions, args: RemainingArgs) = {\n    ???\n  }\n}\n\nobject MyApp extends CommandsEntryPoint {\n  def progName = \"my-app\"\n  def commands = Seq(\n    First,\n    Second\n  )\n}\n</code></pre></p> <p>One gets as a help message: <pre><code>Usage: my-app &lt;COMMAND&gt;\n\nCommands:\n  first\n</code></pre></p>"},{"location":"commands/#command-groups","title":"Command groups","text":"<p>Override the <code>def group: String</code> method of <code>Command</code> to gather similar commands together in the help message listing commands: <pre><code>case class FirstOptions()\n\nobject First extends Command[FirstOptions] {\n  override def group = \"Main\"\n  def run(options: FirstOptions, args: RemainingArgs) = {\n    ???\n  }\n}\n\ncase class SecondOptions()\n\nobject Second extends Command[SecondOptions] {\n  override def group = \"Other\"\n  def run(options: SecondOptions, args: RemainingArgs) = {\n    ???\n  }\n}\n\nobject MyApp extends CommandsEntryPoint {\n  override def defaultCommand = None\n  def progName = \"my-app\"\n  def commands = Seq(\n    First,\n    Second\n  )\n}\n</code></pre></p> <p>One gets as a help message: <pre><code>Usage: my-app &lt;COMMAND&gt;\n\nMain commands:\n  first\n\nOther commands:\n  second\n</code></pre></p> <p>To sort groups, set the <code>sortCommandGroups</code> or <code>sortedCommandGroups</code> command fields of <code>Command#helpFormat</code>, like <pre><code>object MyOtherApp extends CommandsEntryPoint {\n  override def defaultCommand = None\n  def progName = \"my-other-app\"\n  override def helpFormat = super.helpFormat.withSortedCommandGroups(\n    Some(Seq(\"Other\", \"Main\"))\n  )\n  def commands = Seq(\n    First,\n    Second\n  )\n}\n</code></pre></p> <p>One then gets as a help message: <pre><code>Usage: my-other-app &lt;COMMAND&gt;\n\nOther commands:\n  second\n\nMain commands:\n  first\n</code></pre></p>"},{"location":"commands/#standalone-use-of-the-command-argument-parser","title":"Standalone use of the command argument parser","text":"<p>Use one of the overrides of <code>RuntimeCommandParser.parse</code> to parse a list of arguments to a command, like <pre><code>import caseapp.core.commandparser.RuntimeCommandParser\n\ncase class MyCommand(name: String)\n\nval commandMap = Map(\n  List(\"first\") -&gt; MyCommand(\"First one\"),\n  List(\"second\") -&gt; MyCommand(\"Second one\"),\n  List(\"the\", \"first\") -&gt; MyCommand(\"First one\"),\n  List(\"the\", \"second\") -&gt; MyCommand(\"Second one\")\n)\n</code></pre></p> <pre><code>// no default command\nRuntimeCommandParser.parse[MyCommand](\n  commandMap,\n  List(\"the\", \"first\", \"a\", \"--thing\", \"--foo\", \"b\")\n)\n// res13: Option[(List[String], MyCommand, List[String])] = Some(\n//   value = (\n//     List(\"the\", \"first\"),\n//     MyCommand(name = \"First one\"),\n//     List(\"a\", \"--thing\", \"--foo\", \"b\")\n//   )\n// )\n\n// override accepting a default command\nRuntimeCommandParser.parse[MyCommand](\n  MyCommand(\"Default one\"),\n  commandMap,\n  List(\"the\", \"thing\", \"a\", \"--thing\", \"--foo\", \"b\")\n)\n// res14: (List[String], MyCommand, List[String]) = (\n//   List(),\n//   MyCommand(name = \"Default one\"),\n//   List(\"the\", \"thing\", \"a\", \"--thing\", \"--foo\", \"b\")\n// )\n\nRuntimeCommandParser.parse[MyCommand](\n  MyCommand(\"Default one\"),\n  commandMap,\n  List(\"first\", \"a\", \"--thing\", \"--foo\", \"b\")\n)\n// res15: (List[String], MyCommand, List[String]) = (\n//   List(\"first\"),\n//   MyCommand(name = \"First one\"),\n//   List(\"a\", \"--thing\", \"--foo\", \"b\")\n// )\n</code></pre> <p>Note that there are also overrides accepting a <code>Seq[Command[_]]</code> rather than a map like <code>commandMap</code> above, that build the command map out of the <code>Command[_]</code> sequence.</p>"},{"location":"completion/","title":"Completion","text":""},{"location":"completion/#enable-support-for-completion","title":"Enable support for completion","text":"<p>Support for completion relies on commands.</p>"},{"location":"completion/#in-commands","title":"In commands","text":"<p>In an application made of commands, enable completions by overriding the <code>def enableCompletionsCommand: Boolean</code> and <code>def enableCompleteCommand: Boolean</code>.</p> <p>This adds two (hidden) commands to your application: - <code>completions</code> (also aliased to <code>completion</code>): command that allows to help installing   completions - <code>complete</code>: command run when users ask for completions in their shell</p> <p>Overriding <code>def completionsWorkingDirectory: Option[String]</code> and returning a non-empty value from it enables two more commands: - <code>completions install</code> (also aliased to <code>completion install</code>): command to install completions   for the current shell - <code>completions uninstall</code> (also aliased to <code>completion uninstall</code>): command to uninstall   completions for the current shell</p>"},{"location":"completion/#for-simple-applications","title":"For simple applications","text":"<p>If you'd like to enable it in a simple application, make it extend <code>Command</code> rather than <code>CaseApp</code>, and define a <code>CommandsEntryPoint</code> with no commands, and your application as default command: <pre><code>case class Options(\n  foo: String = \"\"\n)\n\nobject MyActualApp extends Command[Options] {\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n\nobject MyApp extends CommandsEntryPoint {\n  def progName = \"my-app\"\n  def commands = Seq()\n  override def defaultCommand = Some(MyActualApp)\n  override def enableCompleteCommand = true\n  override def enableCompletionsCommand = true\n}\n</code></pre></p>"},{"location":"completion/#install-completions","title":"Install completions","text":""},{"location":"completion/#via-completions-install","title":"Via <code>completions install</code>","text":"<p>Assuming <code>progname</code> runs the main class added by <code>CommandEntryPoint</code> to the object extended by it, you can install completions with <pre><code>$ progname completions install\n</code></pre></p> <pre><code>~/.zshrc already up-to-date.\n\nIf needed, enable completions in the current session with\n\n  eval \"$(my-app completions install --env)\"\n</code></pre>"},{"location":"completion/#get-completions","title":"Get completions","text":"<p>The file installed by <code>completions install</code> above runs your application to get completions. It runs it via the <code>complete</code> command, like <pre><code>$ my-app complete zsh-v1 2 my-app -\n</code></pre></p> <pre><code>local -a args1375677408\nargs1375677408=(\n\"--foo\"\n)\n_describe command args1375677408\n</code></pre> <p>Usage: <pre><code>To manually get completions, run\n\n  my-app complete bash-v1|zsh-v1|fish-v1 index command...\n\nwhere index starts from one, and command... includes the command name, like\n\n  my-app complete zsh-v1 2 my-app --\n\nto get completions for '--'\n</code></pre></p>"},{"location":"completion/#provide-completions-for-individual-option-values","title":"Provide completions for individual option values","text":"<pre><code>import caseapp.core.complete.CompletionItem\n\ncase class Options(\n  foo: String = \"\"\n)\n\nobject MyActualApp extends Command[Options] {\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n\n  override def completer =\n    super.completer.completeOptionValue {\n      val hardCodedValues = List(\n        \"aaa\",\n        \"aab\",\n        \"aac\",\n        \"abb\"\n      )\n      (arg, prefix, state, args) =&gt;\n        // provide hard-coded values as completions for --foo values\n        if (arg.names.map(_.name).contains(\"foo\")) {\n          val items = hardCodedValues.filter(_.startsWith(prefix)).map { value =&gt;\n            CompletionItem(value)\n          }\n          Some(items)\n        }\n        else\n          None\n    }\n}\n\nobject MyApp extends CommandsEntryPoint {\n  def progName = \"my-app\"\n  def commands = Seq()\n  override def defaultCommand = Some(MyActualApp)\n  override def enableCompleteCommand = true\n  override def enableCompletionsCommand = true\n}\n</code></pre> <p>One can then get specific completions, like <pre><code>$ my-app complete zsh-v1 3 my-app --foo a\n</code></pre></p> <pre><code>local -a args109470473\nargs109470473=(\n'aaa'\n'aab'\n'aac'\n'abb'\n)\n_describe command args109470473\n</code></pre> <pre><code>$ my-app complete zsh-v1 3 my-app --foo aa\n</code></pre> <pre><code>local -a args515857700\nargs515857700=(\n'aaa'\n'aab'\n'aac'\n)\n_describe command args515857700\n</code></pre>"},{"location":"define/","title":"Defining options","text":""},{"location":"define/#case-classes","title":"Case classes","text":"<p>Options are defined in case classes, like <pre><code>case class Options(\n  foo: Int, // --foo 2, --foo=2\n  enableThing: Boolean // --enableThing, --enableThing=false\n)\n</code></pre></p>"},{"location":"define/#caching-derived-type-classes","title":"Caching derived type classes","text":"<pre><code>// should be the same as below, but for the Scala 3 section\ncase class Options(\n  foo: Int\n)\n\n// Scala 2\nobject Options {\n  implicit lazy val parser: Parser[Options] = Parser.derive\n  implicit lazy val help: Help[Options] = Help.derive\n}\n</code></pre> <p>When defining a case class for options, it is recommended to derive case-app type classes for it in its companion object, like <pre><code>case class Options(\n  foo: Int\n)\n\n// Scala 2\nobject Options {\n  implicit lazy val parser: Parser[Options] = Parser.derive\n  implicit lazy val help: Help[Options] = Help.derive\n}\n\n// Scala 3\n@derives[Parser, Help]\nobject Options\n</code></pre></p> <p>These derivations are omitted in all other examples through out the case-app documentation for brevity, but we highly recommend deriving them there, in order to make incremental compilation faster when the file defining the options isn't modified. This is especially the case in Scala 2, where those type class derivation can be somewhat slow.</p>"},{"location":"define/#mandatory-options","title":"Mandatory options","text":"<p>Options that don't have default values are assumed to be mandatory. To make an option non-mandatory, ensure it has a default value: <pre><code>case class Options(\n  foo: Int, // --foo is mandatory\n  verbosity: Int = 0 // --verbosity is optional\n)\n</code></pre></p>"},{"location":"define/#shared-options","title":"Shared options","text":"<p>Options can be defined across several case classes thanks to the <code>@Recurse</code> annotation, like <pre><code>case class SharedOptions(\n  foo: Int = 0,\n  enableThing: Boolean = false\n)\n\ncase class Options(\n  @Recurse\n    shared: SharedOptions = SharedOptions(),\n  path: String\n)\n</code></pre></p> <p>Shared option classes can themselves have fields marked with <code>@Recurse</code>, whose types can also have fields marked with it, etc.</p>"},{"location":"define/#extra-names","title":"Extra names","text":"<p>Various annotations allow to customize options, like <code>@Name</code> to offer several ways to specify an option: <pre><code>case class Options(\n  @Name(\"f\")\n    foo: Int = 0, // -f 2 and --foo 2 both work\n  @Name(\"t\")\n  @Name(\"thing\")\n    enableThing: Boolean = false // -t, --thing, --enable-thing all work\n)\n</code></pre></p>"},{"location":"define/#field-name-to-option-name-conversion","title":"Field name to option name conversion","text":"<p>Case class field names are assumed to follow the camel case (<code>camelCase</code>), and are converted to kebab case (<code>kebab-case</code>) to get the corresponding option name.</p> <p>Names consisting in a single letter are prefixed with a single hyphen (like <code>-t</code>) while other are prefixed with two hyphens (like <code>--foo-thing</code>). <pre><code>case class Options(\n  @Name(\"f\")\n    foo: Int = 0, // defines options -f and --foo\n  @Name(\"t\")\n  @Name(\"thing\")\n    enableThing: Boolean = false // defines options -t, --thing, and --enable-thing\n)\n</code></pre></p> <p>To enforce a single hyphen for longer options, put the hyphen in the field name, and use kebab case directly, like <pre><code>case class Options(\n  @Name(\"-foo\")\n    foo: Int = 0, // accepts both --foo and -foo\n  `-thing`: Boolean = false // accepts only -thing\n)\n</code></pre></p>"},{"location":"define/#passing-values-to-options","title":"Passing values to options","text":"<p>For option types expecting a value (most of them), that value can be passed in a separated argument, like <pre><code>--foo value\n</code></pre> or with an <code>=</code>, like <pre><code>--foo=value\n</code></pre></p> <p>For option types not expecting a value by default, like <code>Boolean</code>, an optional value can be passed with an <code>=</code>, like <pre><code>--foo=false\n</code></pre></p> <p>This is especially useful for boolean options that are true by default, like <pre><code>case class Options(\n  foo: Boolean = true // can only be disabled with --foo=false\n)\n</code></pre></p>"},{"location":"develop/","title":"Contributing","text":""},{"location":"develop/#building-the-website-locally","title":"Building the website locally","text":""},{"location":"develop/#watch-mode","title":"Watch mode","text":"<p>In a first terminal, run <pre><code>$ ./mill -i -w docs.mdocWatch\n</code></pre></p> <p>Leave it running, and run in a second terminal <pre><code>$ ./mill -i -w docs.mkdocsServe\n</code></pre></p> <p>Then open the URL printed in the console in your browser (it should be <code>http://127.0.0.1:8000</code>)</p>"},{"location":"develop/#once","title":"Once","text":"<p>Build the website in the <code>docs/site</code> directory with <pre><code>$ ./mill -i docs.mkdocsBuild\n</code></pre></p>"},{"location":"help/","title":"Customizing help","text":""},{"location":"help/#annotations","title":"Annotations","text":"<p>A number of annotations can be used, either on fields or on classes defining options, to customize the help message generated by case-app.</p> <pre><code>@AppName(\"My App\")\n@ProgName(\"my-app\")\n@AppVersion(\"0.1.0\")\n@ArgsName(\"things\")\ncase class Options(\n  @HelpMessage(\"How many foos\")\n  @Name(\"f\")\n  @ValueDescription(\"Foo count\")\n    foo: Int = 0\n)\n</code></pre> <p>This makes the help message look like <pre><code>Usage: my-app [options] [things]\n\nOptions:\n  -f, --foo Foo count  How many foos\n</code></pre></p> <p>Without any of the annotations, the help message looks like <pre><code>Usage: options0 [options]\n\nOptions:\n  -f, --foo int\n</code></pre></p>"},{"location":"help/#hidden-options","title":"Hidden options","text":"<p>Annotate an option with <code>@Hidden</code> to hide it from the default help message: <pre><code>case class Options(\n  @Hidden\n    foo: Int = 0,\n  other: String = \"\"\n)\n</code></pre></p> <p>This makes the help message look like <pre><code>Usage: my-app [options]\n\nHelp options:\n  --usage            Print usage and exit\n  -h, -help, --help  Print help message and exit\n\nOther options:\n  --other string\n</code></pre></p> <p>When using hidden options alongside with the <code>CaseApp</code> class, you can offer users to get an help message that includes the hidden options with <code>--full-help</code>, like <pre><code>object MyApp extends CaseApp[Options] {\n  override def hasFullHelp = true\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre></p> <p>We get <pre><code>$ my-app --full-help\n</code></pre></p> <pre><code>Usage: my-app [options]\n\nHelp options:\n  --usage                                        Print usage and exit\n  -h, -help, --help                              Print help message and exit\n  -help-full, -full-help, --help-full, --full-help  Print help message, including hidden options, and exit\n\nOther options:\n  --foo int       (hidden)\n  --other string\n</code></pre>"},{"location":"help/#option-groups","title":"Option groups","text":"<pre><code>case class Options(\n  @Group(\"First\")\n    foo: Int = 0,\n  @Group(\"Second\")\n    other: String = \"\"\n)\n</code></pre> <p>This makes the help message look like <pre><code>Usage: my-app [options]\n\nFirst options:\n  --foo int\n\nHelp options:\n  --usage            Print usage and exit\n  -h, -help, --help  Print help message and exit\n\nSecond options:\n  --other string\n</code></pre></p> <p>When using the <code>CaseApp</code> or <code>Command</code> classes, you can sort groups with <pre><code>object MyApp extends CaseApp[Options] {\n  override def helpFormat = super.helpFormat.withSortedGroups(\n    Some(Seq(\"Help\", \"First\", \"Second\"))\n  )\n  def run(options: Options, args: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre></p> <p>One then gets <pre><code>Usage: my-app [options]\n\nHelp options:\n  --usage            Print usage and exit\n  -h, -help, --help  Print help message and exit\n\nFirst options:\n  --foo int\n\nSecond options:\n  --other string\n</code></pre></p>"},{"location":"misc/","title":"Miscellaneous","text":""},{"location":"misc/#cats-effect","title":"cats-effect","text":"<p>case-app has a module helping using it in cats-effect applications.</p> <p>Add a dependency to it like</p> <p><pre><code>//&gt; using dep com.github.alexarchambault::case-app-cats:2.1.0-M29\n</code></pre> (for other build tools, see setup and change <code>case-app</code> to <code>case-app-cats</code>)</p> <p>Then use it like <pre><code>import caseapp.catseffect._\nimport cats.data.NonEmptyList\nimport cats.effect._\n\ncase class ExampleOptions(\n  foo: String = \"\",\n  thing: NonEmptyList[String]\n)\n\nobject IOCaseExample extends IOCaseApp[ExampleOptions] {\n  def run(options: ExampleOptions, arg: RemainingArgs): IO[ExitCode] = IO {\n    // Core of the app\n    // ...\n    ExitCode.Success\n  }\n}\n</code></pre></p>"},{"location":"parse/","title":"Parsing options","text":"<p>case-app offers several ways to parse input arguments:</p> <ul> <li>method calls,</li> <li>app definitions.</li> </ul>"},{"location":"parse/#method-calls","title":"Method calls","text":"<p>The <code>CaseApp</code> object contains a number of methods that can be used to parse arguments.</p>"},{"location":"parse/#parse","title":"<code>parse</code>","text":"<p><code>CaseApp.parse</code> accepts a sequence of strings, and returns either an error or parsed options and remaining arguments: <pre><code>case class Options(\n  foo: Int = 0\n)\nval args = Seq(\"a\", \"--foo\", \"2\", \"b\")\nval (options, remaining) = CaseApp.parse[Options](args).toOption.get\nassert(options == Options(2))\nassert(remaining == Seq(\"a\", \"b\"))\n\nval either = CaseApp.parse[Options](Seq(\"--foo\", \"a\"))\nassert(either.left.toOption.nonEmpty)\n</code></pre></p>"},{"location":"parse/#parsewithhelp","title":"<code>parseWithHelp</code>","text":"<p><code>CaseApp.parseWithHelp</code> does the same as <code>CaseApp.parse</code>, but also accepts <code>--help</code> / <code>-h</code> / <code>--usage</code> options.</p> <pre><code>CaseApp.parseWithHelp[Options](args) match {\n  case Left(error) =&gt; // invalid options\u2026\n  case Right((Left(error), helpAsked, usageAsked, remaining)) =&gt;\n    // missing mandatory options, but --help or --usage could be parsed\n  case Right((Right(options), helpAsked, usageAsked, remaining)) =&gt;\n    // All is well:\n    // Options were parsed, resulting in options\n    // helpAsked and / or usageAsked are true if either has been requested\n    // remaining contains non-option arguments\n}\n</code></pre>"},{"location":"parse/#detailedparse-detailedparsewithhelp","title":"<code>detailedParse</code>, <code>detailedParseWithHelp</code>","text":"<p><code>CaseApp.detailedParse</code> and <code>CaseApp.detailedParseWithHelp</code> behave the same way as <code>CaseApp.parse</code> and <code>CaseApp.parseWithHelp</code>, but return their remaining arguments as a <code>RemainingArgs</code> instance, rather than a <code>Seq[String]</code>. See below for what <code>RemainingArgs</code> brings.</p>"},{"location":"parse/#process","title":"<code>process</code>","text":"<p><code>CaseApp.process</code> is the most straightforward method to parse arguments. Note that it exits the current application if parsing arguments fails or if users request help, with <code>--help</code> for example.</p> <p>It aims at being used from Scala CLI <code>.sc</code> files (\"Scala scripts\"), where one would rather have case-app handle all errors cases, like <pre><code>//&gt; using dep com.github.alexarchambault::case-app::2.1.0-M29\nimport caseapp._\n\ncase class Options(\n  foo: Int = 0,\n  path: Option[String] = None\n)\n\nval (options, remaining) = CaseApp.process[Options](args.toSeq)\n\n// \u2026\n</code></pre></p>"},{"location":"parse/#application-definition","title":"Application definition","text":"<p>case-app allows one to alter one's main class definitions, so that one defines a method accepting parsed options, rather than raw arguments:</p> <pre><code>case class Options(\n  foo: Int = 0\n)\n\nobject MyApp extends CaseApp[Options] {\n  def run(options: Options, remaining: RemainingArgs): Unit = {\n    ???\n  }\n}\n</code></pre> <p>In that example, case-app defines the <code>MainApp#main</code> method, so that <code>MyApp</code> can be used as a \"main class\".</p>"},{"location":"parse/#parsing","title":"Parsing","text":""},{"location":"parse/#double-hyphen","title":"Double-hyphen","text":"<p>case-app assumes any argument after <code>--</code> is not an option. It stops looking for options after <code>--</code>. Arguments before and after <code>--</code> can be differentiated in the <code>RemainingArgs</code> class: <pre><code>case class Options()\nval (_, args) = CaseApp.detailedParse[Options](Seq(\"first\", \"--\", \"foo\")).toOption.get\n</code></pre> <pre><code>args.remaining\n// res8: Seq[String] = List(\"first\")\nargs.unparsed\n// res9: Seq[String] = List(\"foo\")\nargs.all\n// res10: Seq[String] = List(\"first\", \"foo\")\n</code></pre></p>"},{"location":"setup/","title":"Setup","text":"<p>Depend on case-app via <code>com.github.alexarchambault::case-app:2.1.0-M29</code>. The latest version is .</p>"},{"location":"setup/#jvm","title":"JVM","text":"<p>From Mill: <pre><code>def ivyDeps = Agg(\n  ivy\"com.github.alexarchambault::case-app:2.1.0-M29\"\n)\n</code></pre></p> <p>From Scala CLI: <pre><code>//&gt; using dep com.github.alexarchambault::case-app:2.1.0-M29\n</code></pre></p> <p>From sbt: <pre><code>libraryDependencies += \"com.github.alexarchambault\" %% \"case-app\" % \"2.1.0-M29\"\n</code></pre></p>"},{"location":"setup/#scalajs-and-scala-native","title":"Scala.js and Scala Native","text":"<p>Scala.js and Scala Native dependencies need to be marked as platform-specific, usually with an extra <code>:</code> or <code>%</code>.</p> <p>From Mill: <pre><code>def ivyDeps = Agg(\n  ivy\"com.github.alexarchambault::case-app::2.1.0-M29\"\n)\n</code></pre></p> <p>From Scala CLI: <pre><code>//&gt; using dep com.github.alexarchambault::case-app::2.1.0-M29\n</code></pre></p> <p>From sbt: <pre><code>libraryDependencies += \"com.github.alexarchambault\" %%% \"case-app\" % \"2.1.0-M29\"\n</code></pre></p>"},{"location":"setup/#imports","title":"Imports","text":"<p>Most case-app classes that are of relevance for end-users have aliases in the <code>caseapp</code> package object. Importing its content is usually fine to use most case-app features: <pre><code>import caseapp._\n</code></pre></p>"},{"location":"types/","title":"Option types","text":"<p>case-app pre-defines parsers for a number of standard types, and allows you to define parsers of your own.</p>"},{"location":"types/#booleans","title":"Booleans","text":"<p>Boolean fields are mapped to \"flags\", that is options not requiring a value: <pre><code>case class Options(\n  foo: Boolean // --foo\n)\n</code></pre></p> <p>While these do not require a value, one can be passed explicitly, with an <code>=</code> sign, like <code>--foo=true</code> or <code>--foo=false</code>. This is especially useful for boolean fields whose default value is <code>true</code> and is not changed when users specify the flag without a value.</p>"},{"location":"types/#strings","title":"Strings","text":"<p>String fields are given the value passed to the option as is: <pre><code>case class Options(\n  foo: String\n)\n\nval (options, _) = CaseApp.parse[Options](Seq(\"--foo\", \"123\")).toOption.get\n// options: Options = Options(foo = \"123\")\n</code></pre></p>"},{"location":"types/#numerical-values","title":"Numerical values","text":"<p>Integer types like <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, and floating ones like <code>Double</code>, <code>Float</code>, <code>BigDecimal</code> are all accepted as field types.</p>"},{"location":"types/#options","title":"Options","text":"<p>Field types wrapped in <code>Option[_]</code> are automatically non-mandatory, even when the field doesn't have a default value.</p> <p>Option types are convenient to know whether an option was specified (the field value is then <code>Some(\u2026)</code>) or not (field value is <code>None</code>), and behave differently if the option wasn't specified, like default to the value of another option say.</p>"},{"location":"types/#sequences","title":"Sequences","text":"<p>Sequences allow users to specify an argument more than once, and get the different values passed each time: <pre><code>case class Options(\n  path: List[String]\n)\n\nval (options, _) = CaseApp.parse[Options](Seq(\"--path\", \"/a\", \"--path\", \"/b\", \"--path\", \"/c\")).toOption.get\n// options: Options = Options(path = List(\"/a\", \"/b\", \"/c\"))\n</code></pre></p> <p>Only <code>List</code> and <code>Vector</code> are accepted with the default parsers, no generic <code>Seq</code> for example.</p> <p>The options corresponding to sequence fields are not mandatory even if the field doesn't have a default value. If no option for it is specified, it will default to an empty sequence.</p>"},{"location":"types/#last","title":"Last","text":"<p><code>Last</code> is an ad-hoc type defined by case-app. Like sequence types, it allows an option to be specified multiple times.</p> <p>Yet, unlike sequence types, it just discards the values passed to the option, but for the last one.</p> <p>So <code>Last</code> makes option parsing not fail if its option is specified multiple time, and just retains the last occurrence of it.</p>"},{"location":"types/#counters","title":"Counters","text":"<p>One may want to allow flags to be specified multiple times. This can be achieved in two ways out-of-the-box with case-app: <pre><code>case class Options(\n  verbose: Int @@ Counter = Tag.of(0),\n  debug: List[Unit]\n)\n\nval (options, _) = CaseApp.parse[Options](\n  Seq(\"--verbose\", \"--debug\", \"--verbose\", \"--verbose\", \"--debug\")\n).toOption.get\n// options: Options = Options(verbose = @@(value = 3), debug = List((), ()))\nTag.unwrap(options.verbose) // --verbose specified 3 times\n// res4: Int = 3\noptions.debug.length // --debug specified 2 times\n// res5: Int = 2\n</code></pre></p> <p><code>@@</code> and <code>Tag</code> are ad-hoc types defined by case-app, that look like types with similar names defined in the shapeless library. These aim at helping \"tagging\" or \"annotating\" a type. <code>Counter</code> is also defined in case-app.</p> <p>Using <code>List[Unit]</code> as a type also works. <code>Unit</code> itself could be used as a type, but would be of little help. A field with type <code>Unit</code> is mapped to a flag option, like <code>Boolean</code>, but the <code>Unit</code> type itself doesn't allow to retain if the flag was specified by users or not. In a <code>List</code> on the other hand, counting the number of <code>()</code> (<code>Unit</code> instance) in the list allows to know how many types the flag was specified.</p>"},{"location":"types/#custom-parsers","title":"Custom parsers","text":"<p>For a type to be accepted as an option, it needs to have an implicit <code>ArgParser</code> in scope.</p> <p>The abstract and overriddable methods of <code>ArgParser</code> are quite low-level, but allow to implement all the kind of parsers defined in case-app.</p> <p>For simple types, when one only wants to parse a string to a given type, <code>SimpleArgParser</code> allows to define an <code>ArgParser</code> out of a <code>String =&gt; T</code> method. For example, one can define a parser for integer values with: <pre><code>import caseapp.core.argparser.{ArgParser, SimpleArgParser}\nimport caseapp.core.Error\n\ncase class MyInt(value: Int)\n\nimplicit lazy val myIntParser: ArgParser[MyInt] =\n  SimpleArgParser.from(\"my-int\") { input =&gt;\n    try Right(MyInt(input.toInt))\n    catch {\n      case _: NumberFormatException =&gt;\n        Left(Error.MalformedValue(\"integer\", input))\n    }\n  }\n</code></pre></p>"}]}