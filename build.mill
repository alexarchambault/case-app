//| mill-version: 1.0.1
//| mvnDeps:
//| - com.github.lolgab::mill-mima_mill1:0.2.0

package build

import com.github.lolgab.mill.mima.Mima
import mill._
import mill.api.{BuildCtx, Result, ref}
import mill.javalib.api.JvmWorkerUtil.matchingVersions
import mill.scalajslib._
import mill.scalalib._
import mill.scalanativelib._

import java.io.File

import scala.concurrent.duration.DurationInt

object Versions {
  def scala212 = "2.12.20"
  def scala213 = "2.13.16"
  def scala3   = "3.3.6"
  def scala    = Seq(scala212, scala213, scala3)

  def scalaJs     = "1.19.0"
  def scalaNative = "0.5.8"
}

object Deps {
  def catsEffect                = mvn"org.typelevel::cats-effect::3.6.3"
  def catsEffect2               = mvn"org.typelevel::cats-effect::2.5.5"
  def dataClass                 = mvn"io.github.alexarchambault::data-class:0.2.7"
  def macroParadise             = mvn"org.scalamacros:::paradise:2.1.1"
  def mdoc                      = mvn"org.scalameta::mdoc:2.7.2"
  def osLib                     = mvn"com.lihaoyi::os-lib::0.11.4"
  def pprint                    = mvn"com.lihaoyi::pprint::0.9.3"
  def scalaCompiler(sv: String) = mvn"org.scala-lang:scala-compiler:$sv"
  def scalaReflect(sv: String)  = mvn"org.scala-lang:scala-reflect:$sv"
  def shapeless                 = mvn"com.chuusai::shapeless::2.3.13"
  def sourcecode                = mvn"com.lihaoyi::sourcecode::0.4.2"
  def utest                     = mvn"com.lihaoyi::utest::0.8.9"
}

def scalaVersion = Task.CrossValue(Versions.scala)

object annotations extends Module {
  object shared extends SharedSources

  object jvm    extends Annotations with MimaChecks
  object js     extends Annotations with CaseAppScalaJsModule with MimaChecks
  object native extends Annotations with CaseAppScalaNativeModule

  trait Annotations extends SbtModule with CaseAppPublishModule with shared.AddSources {
    def scalaVersion = Task(build.scalaVersion())
    def artifactName = "case-app-annotations"
  }
}

object util extends Module {
  object shared extends SharedSources

  object jvm    extends Util with MimaChecks
  object js     extends Util with CaseAppScalaJsModule with MimaChecks
  object native extends Util with CaseAppScalaNativeModule

  trait Util extends SbtModule with CaseAppPublishModule with shared.AddSources {
    def scalaVersion = build.scalaVersion()
    def artifactName = "case-app-util"
    def mvnDeps = Task {
      val maybeShapeless =
        if (scalaVersion().startsWith("2.")) Seq(Deps.shapeless)
        else Nil
      super.mvnDeps() ++ maybeShapeless
    }
    def compileMvnDeps = Task {
      val maybeScala2Compiler =
        if (scalaVersion().startsWith("2."))
          Seq(
            Deps.scalaCompiler(scalaVersion()),
            Deps.scalaReflect(scalaVersion())
          )
        else
          Nil
      super.compileMvnDeps() ++ maybeScala2Compiler
    }
  }
}

object core extends Module {
  object shared       extends SharedSources
  object `jvm-native` extends SharedSources

  object jvm extends CoreJvmNative with MimaChecks {
    def moduleDeps = Seq(
      annotations.jvm,
      util.jvm
    )
  }
  object js extends Core with CaseAppScalaJsModule with MimaChecks {
    def moduleDeps = Seq(
      annotations.js,
      util.js
    )
  }
  object native extends CoreJvmNative with CaseAppScalaNativeModule {
    def moduleDeps = Seq(
      annotations.native,
      util.native
    )
  }

  trait Core extends SbtModule with CaseAppPublishModule with shared.AddSources {
    def scalaVersion = build.scalaVersion()
    def artifactName = "case-app"
    def mvnDeps = Task {
      val maybeDataClass =
        if (scalaVersion().startsWith("2.")) Seq(Deps.dataClass)
        else Nil
      super.mvnDeps() ++ Seq(Deps.sourcecode) ++ maybeDataClass
    }
    def scalacOptions = Task {
      val maybeMacroAnn =
        if (scalaVersion().startsWith("2.13."))
          Seq("-Ymacro-annotations")
        else
          Nil
      super.scalacOptions() ++ maybeMacroAnn
    }
    def scalacPluginMvnDeps = Task {
      if (scalaVersion().startsWith("2.12."))
        Seq(Deps.macroParadise)
      else
        Nil
    }
  }
  trait CoreJvmNative extends Core {
    def sources = Task(super.sources() ++ `jvm-native`.sources())
  }
}

object cats extends Module {
  object shared extends SharedSources

  object jvm extends Cats with MimaChecks {
    def moduleDeps = Seq(core.jvm)

    object test extends CatsTests
  }
  object js extends Cats with CaseAppScalaJsModule with MimaChecks {
    def moduleDeps = Seq(core.js)

    object test extends CatsTests with ScalaJSTests
  }

  trait Cats extends SbtModule with CaseAppPublishModule with shared.AddSources {
    def scalaVersion = build.scalaVersion()
    def artifactName = "case-app-cats"
    def mvnDeps      = super.mvnDeps() ++ Seq(Deps.catsEffect)

    trait CatsTests extends SbtTests with shared.AddTestSources {
      def mvnDeps       = super.mvnDeps() ++ Seq(Deps.utest)
      def testFramework = "utest.runner.Framework"
    }
  }
}

object cats2 extends Module {
  object shared extends SharedSources

  object jvm extends Cats2 with MimaChecks {
    def moduleDeps = Seq(core.jvm)
    def sources    = Task(cats.jvm.sources())

    object test extends Cats2Tests
  }
  object js extends Cats2 with CaseAppScalaJsModule with MimaChecks {
    def moduleDeps = Seq(core.js)
    def sources    = Task(cats.js.sources())

    object test extends Cats2Tests with ScalaJSTests
  }

  trait Cats2 extends SbtModule with CaseAppPublishModule {
    def scalaVersion = build.scalaVersion()
    def artifactName = "case-app-cats-effect-2"
    def mvnDeps      = super.mvnDeps() ++ Seq(Deps.catsEffect2)

    trait Cats2Tests extends SbtTests with shared.AddTestSources {
      def mvnDeps       = super.mvnDeps() ++ Seq(Deps.utest)
      def testFramework = "utest.runner.Framework"
    }
  }
}

object tests extends Module {
  object shared       extends SharedSources
  object `jvm-native` extends SharedSources

  object jvm extends Tests0JvmNative {
    def moduleDeps = Seq(core.jvm)

    object test extends Tests0JvmNativeTests
  }
  object js extends Tests0 with CaseAppScalaJsModule {
    def moduleDeps = Seq(core.js)

    object test extends Tests0Tests with ScalaJSTests
  }
  object native extends Tests0JvmNative with CaseAppScalaNativeModule {
    def moduleDeps = Seq(core.native)

    def testSources = Task.Sources(SharedSources.sourceDirs(build.scalaVersion(), "test")*)
    object test extends Tests0JvmNativeTests with ScalaNativeTests {
      def sources = Task((super.sources() ++ testSources()).distinct)
    }
  }

  trait Tests0 extends SbtModule with shared.AddSources {
    def scalaVersion = build.scalaVersion()
    def mvnDeps = Task {
      val maybeDataClass =
        if (scalaVersion().startsWith("2.")) Seq(Deps.dataClass)
        else Nil
      super.mvnDeps() ++ Seq(Deps.sourcecode) ++ maybeDataClass
    }

    trait Tests0Tests extends SbtTests with shared.AddTestSources {
      def mvnDeps = super.mvnDeps() ++ Seq(
        Deps.pprint,
        Deps.utest
      )
      def testFramework = "utest.runner.Framework"
    }
  }
  trait Tests0JvmNative extends Tests0 {
    def sources = Task(super.sources() ++ `jvm-native`.sources())
    trait Tests0JvmNativeTests extends Tests0Tests {
      def mvnDeps = super.mvnDeps() ++ Seq(Deps.osLib)
      def sources = Task(super.sources() ++ `jvm-native`.testSources())
    }
  }
}

trait CaseAppScalaJsModule extends ScalaJSModule {
  def scalaJSVersion = Versions.scalaJs
}

trait CaseAppScalaNativeModule extends ScalaNativeModule {
  def scalaNativeVersion = Versions.scalaNative
}

trait CaseAppPublishModule extends PublishModule with ScalaModule {
  import CaseAppPublishModule._
  import mill.scalalib.publish._
  def pomSettings = PomSettings(
    description = artifactName(),
    organization = "com.github.alexarchambault",
    url = "https://github.com/alexarchambault/case-app",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github("alexarchambault", "case-app"),
    developers = Seq(
      Developer("alexarchambault", "Alex Archambault", "https://github.com/alexarchambault")
    )
  )
  def publishVersion = Task(buildVersion)

  def javacOptions = super.javacOptions() ++ Seq(
    "--release",
    "8"
  )
  def scalacOptions = super.scalacOptions() ++ Seq(
    "--release",
    "8"
  )
}

object CaseAppPublishModule {
  private lazy val latestTaggedVersion =
    os.proc("git", "describe", "--abbrev=0", "--tags", "--match", "v*")
      .call().out
      .trim()
  private lazy val buildVersion = {
    val gitHead = os.proc("git", "rev-parse", "HEAD").call().out.trim()
    val maybeExactTag = scala.util.Try {
      os.proc("git", "describe", "--exact-match", "--tags", "--always", gitHead)
        .call().out
        .trim()
        .stripPrefix("v")
    }
    maybeExactTag.toOption.getOrElse {
      val commitsSinceTaggedVersion =
        os.proc("git", "rev-list", gitHead, "--not", latestTaggedVersion, "--count")
          .call().out.trim()
          .toInt
      val gitHash = os.proc("git", "rev-parse", "--short", "HEAD").call().out.trim()
      s"${latestTaggedVersion.stripPrefix("v")}-$commitsSinceTaggedVersion-$gitHash-SNAPSHOT"
    }
  }
}

object SharedSources {
  def sourceDirs(sv: String, `type`: String = "main") =
    Seq(
      os.sub / "src" / `type` / "java",
      os.sub / "src" / `type` / "scala"
    ) ++
      matchingVersions(sv).map { sv0 =>
        os.sub / "src" / `type` / s"scala-$sv0"
      }
}

trait SharedSources extends Module { shared =>
  def sources     = Task.Sources(SharedSources.sourceDirs(build.scalaVersion())*)
  def testSources = Task.Sources(SharedSources.sourceDirs(build.scalaVersion(), "test")*)

  trait AddSources extends JavaModule {
    def sources = Task(super.sources() ++ shared.sources())
  }
  trait AddTestSources extends JavaModule {
    def sources = Task(super.sources() ++ shared.testSources())
  }
}

trait MimaChecks extends Mima with PublishModule {
  def mimaPreviousVersions = Task {
    os.proc(
      "git",
      "tag",
      "--merged",
      "HEAD^",
      "--contains",
      "27cdd86548d413c656b9493e625523b1e642c9be"
    )
      .call()
      .out.lines()
      .map(_.trim)
      .filter(_.startsWith("v"))
      .map(_.stripPrefix("v"))
  }

  def mimaPreviousArtifacts = Task {
    val versions = mimaPreviousVersions().distinct
    Result.Success(
      versions.map { version =>
        mvn"${pomSettings().organization}:${artifactId()}:$version"
      }
    )
  }
}

object docs extends ScalaModule {
  private def sv   = Versions.scala213
  def scalaVersion = sv
  def moduleDeps = Seq(
    cats.jvm.ref.addCrossValues(Seq("scalaVersion" -> sv))
  )
  def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.mdoc
  )
  def mainClass = Some("mdoc.Main")

  def mdocInput        = Task.Sources(os.sub / "pages")
  def mkdocsConfigFile = Task.Sources(os.sub / "mkdocs.yml")

  def mkdocsOutput = Task {
    PathRef(moduleDir / "site")
  }

  def mdocArgs = Task.Anon {
    val mdocInput0 = mdocInput().map(_.path)
    assert(mdocInput0.length == 1)
    val outDir = moduleDir / "docs"
    os.makeDir.all(outDir)
    Args(
      "--in",
      mdocInput0.head,
      "--out",
      outDir,
      "--site.VERSION",
      core.jvm.ref
        .addCrossValues(Seq("scalaVersion" -> sv))
        .task(_.publishVersion)(),
      "--classpath",
      runClasspath().map(_.path).mkString(File.pathSeparator),
      "--disableUsingDirectives"
    )
  }
  def mdocWatchArgs = Task.Anon {
    new Args(
      mdocArgs().value :+ "--watch"
    )
  }

  def mdoc() = Task.Command[Unit] {
    run(mdocArgs)()
  }
  def mdocWatch() = Task.Command[Unit] {
    run(mdocWatchArgs)()
  }

  def mkdocsConfigArgs = Task {
    val mkdocsConfigFile0 = mkdocsConfigFile().map(_.path)
    assert(mkdocsConfigFile0.length == 1)
    Seq("--config-file", mkdocsConfigFile0.head.toString)
  }
  def mkdocsSiteDirArgs = Task {
    Seq("--site-dir", mkdocsOutput().path.toString)
  }
  def mkdocsServe() = Task.Command[Unit] {
    mdoc()()
    val docsDir = BuildCtx.workspaceRoot / "docs"
    val serveProc = os.proc("mkdocs", "serve", mkdocsConfigArgs())
      .spawn(cwd = docsDir, stdin = os.Inherit, stdout = os.Inherit)
    val mdocProc = os.proc(
      "java",
      "-cp",
      compileClasspath().map(_.path).mkString(File.pathSeparator),
      mainClass().getOrElse(???),
      mdocWatchArgs().value
    )
      .spawn(cwd = docsDir, stdin = os.Inherit, stdout = os.Inherit)

    while (serveProc.isAlive() && mdocProc.isAlive())
      Thread.sleep(1000L)

    serveProc.waitFor()
    mdocProc.waitFor()
    val serveRetCode = serveProc.exitCode()
    val mdocRetCode  = mdocProc.exitCode()
    if (serveRetCode != 0 || mdocRetCode != 0)
      sys.error(s"Got exit code $serveRetCode for mkdocs serve and $mdocRetCode for mdoc")
    ()
  }
  def mkdocsBuild() = Task.Command[Unit] {
    mdoc()()
    os.proc("mkdocs", "build", mkdocsConfigArgs(), mkdocsSiteDirArgs())
      .call(cwd = moduleDir, stdin = os.Inherit, stdout = os.Inherit)

    ()
  }
  def mkdocsGhDeploy() = Task.Command[Unit] {
    mdoc()()
    os.proc("mkdocs", "gh-deploy", mkdocsConfigArgs(), mkdocsSiteDirArgs())
      .call(cwd = moduleDir, stdin = os.Inherit, stdout = os.Inherit)

    ()
  }
}
